/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * @record
 */
export function ParseConfig() { }
/**
 * The delimiting character. Leave blank to auto-detect from a list of most common delimiters, or any values passed in through
 * delimitersToGuess. It can be a string or a function. If string, it must be one of length 1. If a function, it must accept the input
 * as first parameter and it must return a string which will be used as delimiter.
 * In both cases it cannot be found in Papa.badDelimiters.
 * @type {?|undefined}
 */
ParseConfig.prototype.delimiter;
/**
 * The newline sequence. Leave blank to auto-detect.
 * @type {?|undefined}
 */
ParseConfig.prototype.newline;
/**
 * The character used to quote fields. The quoting of all fields is not mandatory. Any field which is not quoted will correctly read.
 * @type {?|undefined}
 */
ParseConfig.prototype.quoteChar;
/**
 * The character used to escape the quote character within a field. If not set, this option will default to the value of quoteChar,
 * meaning that the default escaping of quote character within a quoted field is using the quote character
 * two times. (e.g. "column with ""quotes"" in text")
 * @type {?|undefined}
 */
ParseConfig.prototype.escapeChar;
/**
 * If true, the first row of parsed data will be interpreted as field names.
 * An array of field names will be returned in meta, and each row of data will be an object of values keyed by field name instead of
 * a simple array. Rows with a different number of fields from the header row will produce an error.
 * Warning: Duplicate field names will overwrite values in previous fields having the same name.
 * @type {?|undefined}
 */
ParseConfig.prototype.header;
/**
 * A function to apply on each header. Requires header to be true. The function receives the header as its first argument.
 * @type {?|undefined}
 */
ParseConfig.prototype.transformHeader;
/**
 * If true, numeric and boolean data will be converted to their type instead of remaining strings.
 * Numeric data must conform to the definition of a decimal literal. European-formatted numbers must have commas and dots swapped.
 * It also accepts an object or a function. If object it's values should be a boolean to indicate if dynamic typing should be applied
 * for each column number (or header name if using headers). If it's a function, it should return a boolean value for each field number
 * (or name if using headers) which will be passed as first argument.
 * @type {?|undefined}
 */
ParseConfig.prototype.dynamicTyping;
/**
 * If > 0, only that many rows will be parsed.
 * @type {?|undefined}
 */
ParseConfig.prototype.preview;
/**
 * The encoding to use when opening local files. If specified, it must be a value supported by the FileReader API.
 * @type {?|undefined}
 */
ParseConfig.prototype.encoding;
/**
 * Whether or not to use a worker thread. Using a worker will keep your page reactive, but may be slightly slower.
 * @type {?|undefined}
 */
ParseConfig.prototype.worker;
/**
 * A string that indicates a comment (for example, "#" or "//").
 * When Papa encounters a line starting with this string, it will skip the line.
 * @type {?|undefined}
 */
ParseConfig.prototype.comments;
/**
 * Streaming is necessary for large files which would otherwise crash the browser. You can call parser.abort() to abort parsing.
 * And, except when using a Web Worker, you can call parser.pause() to pause it, and parser.resume() to resume.
 * @type {?|undefined}
 */
ParseConfig.prototype.step;
/**
 * The callback to execute when parsing is complete. It receives the parse results. If parsing a local file, the File is passed in, too.
 * When streaming, parse results are not available in this callback.
 * @type {?|undefined}
 */
ParseConfig.prototype.complete;
/**
 * A callback to execute if FileReader encounters an error.
 * @type {?|undefined}
 */
ParseConfig.prototype.error;
/**
 * If true, this indicates that the string you passed as the first argument to parse()
 * is actually a URL from which to download a file and parse it's contents.
 * @type {?|undefined}
 */
ParseConfig.prototype.download;
/**
 * Headers to be included in the download request.
 * @type {?|undefined}
 */
ParseConfig.prototype.downloadRequestHeaders;
/**
 * If true, lines that are completely empty (those which evaluate to an empty string) will be skipped. If set to 'greedy',
 * lines that don't have any content (those which have only whitespace after parsing) will also be skipped.
 * @type {?|undefined}
 */
ParseConfig.prototype.skipEmptyLines;
/**
 * A callback function, identical to step, which activates streaming.
 * However, this function is executed after every chunk of the file is loaded and parsed rather than every row.
 * Works only with local and remote files. Do not use both chunk and step callbacks together.
 * @type {?|undefined}
 */
ParseConfig.prototype.chunk;
/**
 * Fast mode speeds up parsing significantly for large inputs. However, it only works when the input has no quoted fields.
 * Fast mode will automatically be enabled if no " characters appear in the input.
 * You can force fast mode either way by setting it to true or false.
 * @type {?|undefined}
 */
ParseConfig.prototype.fastMode;
/**
 * A function to execute before parsing the first chunk. Can be used with chunk or step streaming modes.
 * The function receives as an argument the chunk about to be parsed, and it may return a modified chunk to parse.
 * This is useful for stripping header lines (as long as the header fits in a single chunk).
 * @type {?|undefined}
 */
ParseConfig.prototype.beforeFirstChunk;
/**
 * A boolean value passed directly into XMLHttpRequest's "withCredentials" property.
 * @type {?|undefined}
 */
ParseConfig.prototype.withCredentials;
/**
 * A function to apply on each value. The function receives the value as its first argument and the column number or
 * header name when enabled as its second argument. The return value of the function will replace the value it received.
 * The transform function is applied before dynamicTyping.
 * @type {?|undefined}
 */
ParseConfig.prototype.transform;
/**
 * An array of delimiters to guess from if the delimiter option is not set.
 * @type {?|undefined}
 */
ParseConfig.prototype.delimitersToGuess;

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGFyc2UtY29uZmlnLmpzIiwic291cmNlUm9vdCI6Im5nOi8vbmd4LXBhcGFwYXJzZS8iLCJzb3VyY2VzIjpbImxpYi9pbnRlcmZhY2VzL3BhcnNlLWNvbmZpZy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUGFyc2VSZXN1bHQgfSBmcm9tICcuL3BhcnNlLXJlc3VsdCc7XG5pbXBvcnQgeyBQYXBhUGFyc2VQYXJzZXIgfSBmcm9tICcuL3BhcGEtcGFyc2UtcGFyc2VyJztcblxuZXhwb3J0IGludGVyZmFjZSBQYXJzZUNvbmZpZyB7XG4gICAgLyoqXG4gICAgICogVGhlIGRlbGltaXRpbmcgY2hhcmFjdGVyLiBMZWF2ZSBibGFuayB0byBhdXRvLWRldGVjdCBmcm9tIGEgbGlzdCBvZiBtb3N0IGNvbW1vbiBkZWxpbWl0ZXJzLCBvciBhbnkgdmFsdWVzIHBhc3NlZCBpbiB0aHJvdWdoXG4gICAgICogZGVsaW1pdGVyc1RvR3Vlc3MuIEl0IGNhbiBiZSBhIHN0cmluZyBvciBhIGZ1bmN0aW9uLiBJZiBzdHJpbmcsIGl0IG11c3QgYmUgb25lIG9mIGxlbmd0aCAxLiBJZiBhIGZ1bmN0aW9uLCBpdCBtdXN0IGFjY2VwdCB0aGUgaW5wdXRcbiAgICAgKiBhcyBmaXJzdCBwYXJhbWV0ZXIgYW5kIGl0IG11c3QgcmV0dXJuIGEgc3RyaW5nIHdoaWNoIHdpbGwgYmUgdXNlZCBhcyBkZWxpbWl0ZXIuXG4gICAgICogSW4gYm90aCBjYXNlcyBpdCBjYW5ub3QgYmUgZm91bmQgaW4gUGFwYS5iYWREZWxpbWl0ZXJzLlxuICAgICAqL1xuICAgIGRlbGltaXRlcj86IHN0cmluZyB8ICgoaW5wdXQ/OiBzdHJpbmcpID0+IHN0cmluZyk7IC8vIFRPRE8gdGVzdCBmdW5jdGlvblxuXG4gICAgLyoqXG4gICAgICogVGhlIG5ld2xpbmUgc2VxdWVuY2UuIExlYXZlIGJsYW5rIHRvIGF1dG8tZGV0ZWN0LlxuICAgICAqL1xuICAgIG5ld2xpbmU/OiAnXFxyJ3wnXFxuJ3wnXFxyXFxuJ3wnJztcblxuICAgIC8qKlxuICAgICAqIFRoZSBjaGFyYWN0ZXIgdXNlZCB0byBxdW90ZSBmaWVsZHMuIFRoZSBxdW90aW5nIG9mIGFsbCBmaWVsZHMgaXMgbm90IG1hbmRhdG9yeS4gQW55IGZpZWxkIHdoaWNoIGlzIG5vdCBxdW90ZWQgd2lsbCBjb3JyZWN0bHkgcmVhZC5cbiAgICAgKi9cbiAgICBxdW90ZUNoYXI/OiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgY2hhcmFjdGVyIHVzZWQgdG8gZXNjYXBlIHRoZSBxdW90ZSBjaGFyYWN0ZXIgd2l0aGluIGEgZmllbGQuIElmIG5vdCBzZXQsIHRoaXMgb3B0aW9uIHdpbGwgZGVmYXVsdCB0byB0aGUgdmFsdWUgb2YgcXVvdGVDaGFyLFxuICAgICAqIG1lYW5pbmcgdGhhdCB0aGUgZGVmYXVsdCBlc2NhcGluZyBvZiBxdW90ZSBjaGFyYWN0ZXIgd2l0aGluIGEgcXVvdGVkIGZpZWxkIGlzIHVzaW5nIHRoZSBxdW90ZSBjaGFyYWN0ZXJcbiAgICAgKiB0d28gdGltZXMuIChlLmcuIFwiY29sdW1uIHdpdGggXCJcInF1b3Rlc1wiXCIgaW4gdGV4dFwiKVxuICAgICAqL1xuICAgIGVzY2FwZUNoYXI/OiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBJZiB0cnVlLCB0aGUgZmlyc3Qgcm93IG9mIHBhcnNlZCBkYXRhIHdpbGwgYmUgaW50ZXJwcmV0ZWQgYXMgZmllbGQgbmFtZXMuXG4gICAgICogQW4gYXJyYXkgb2YgZmllbGQgbmFtZXMgd2lsbCBiZSByZXR1cm5lZCBpbiBtZXRhLCBhbmQgZWFjaCByb3cgb2YgZGF0YSB3aWxsIGJlIGFuIG9iamVjdCBvZiB2YWx1ZXMga2V5ZWQgYnkgZmllbGQgbmFtZSBpbnN0ZWFkIG9mXG4gICAgICogYSBzaW1wbGUgYXJyYXkuIFJvd3Mgd2l0aCBhIGRpZmZlcmVudCBudW1iZXIgb2YgZmllbGRzIGZyb20gdGhlIGhlYWRlciByb3cgd2lsbCBwcm9kdWNlIGFuIGVycm9yLlxuICAgICAqIFdhcm5pbmc6IER1cGxpY2F0ZSBmaWVsZCBuYW1lcyB3aWxsIG92ZXJ3cml0ZSB2YWx1ZXMgaW4gcHJldmlvdXMgZmllbGRzIGhhdmluZyB0aGUgc2FtZSBuYW1lLlxuICAgICAqL1xuICAgIGhlYWRlcj86IGJvb2xlYW47XG5cbiAgICAvKipcbiAgICAgKiBBIGZ1bmN0aW9uIHRvIGFwcGx5IG9uIGVhY2ggaGVhZGVyLiBSZXF1aXJlcyBoZWFkZXIgdG8gYmUgdHJ1ZS4gVGhlIGZ1bmN0aW9uIHJlY2VpdmVzIHRoZSBoZWFkZXIgYXMgaXRzIGZpcnN0IGFyZ3VtZW50LlxuICAgICAqL1xuICAgIHRyYW5zZm9ybUhlYWRlcj86IChoZWFkZXI6IHN0cmluZykgPT4gc3RyaW5nOyAvLyBUT0RPIFRlc3QgZnVuY3Rpb25cblxuICAgIC8qKlxuICAgICAqIElmIHRydWUsIG51bWVyaWMgYW5kIGJvb2xlYW4gZGF0YSB3aWxsIGJlIGNvbnZlcnRlZCB0byB0aGVpciB0eXBlIGluc3RlYWQgb2YgcmVtYWluaW5nIHN0cmluZ3MuXG4gICAgICogTnVtZXJpYyBkYXRhIG11c3QgY29uZm9ybSB0byB0aGUgZGVmaW5pdGlvbiBvZiBhIGRlY2ltYWwgbGl0ZXJhbC4gRXVyb3BlYW4tZm9ybWF0dGVkIG51bWJlcnMgbXVzdCBoYXZlIGNvbW1hcyBhbmQgZG90cyBzd2FwcGVkLlxuICAgICAqIEl0IGFsc28gYWNjZXB0cyBhbiBvYmplY3Qgb3IgYSBmdW5jdGlvbi4gSWYgb2JqZWN0IGl0J3MgdmFsdWVzIHNob3VsZCBiZSBhIGJvb2xlYW4gdG8gaW5kaWNhdGUgaWYgZHluYW1pYyB0eXBpbmcgc2hvdWxkIGJlIGFwcGxpZWRcbiAgICAgKiBmb3IgZWFjaCBjb2x1bW4gbnVtYmVyIChvciBoZWFkZXIgbmFtZSBpZiB1c2luZyBoZWFkZXJzKS4gSWYgaXQncyBhIGZ1bmN0aW9uLCBpdCBzaG91bGQgcmV0dXJuIGEgYm9vbGVhbiB2YWx1ZSBmb3IgZWFjaCBmaWVsZCBudW1iZXJcbiAgICAgKiAob3IgbmFtZSBpZiB1c2luZyBoZWFkZXJzKSB3aGljaCB3aWxsIGJlIHBhc3NlZCBhcyBmaXJzdCBhcmd1bWVudC5cbiAgICAgKi9cbiAgICBkeW5hbWljVHlwaW5nPzogYm9vbGVhbjsgLy8gVE9ETyBhZGQgb2JqZWN0IGFuZCBmdW5jdGlvblxuXG4gICAgLyoqXG4gICAgICogSWYgPiAwLCBvbmx5IHRoYXQgbWFueSByb3dzIHdpbGwgYmUgcGFyc2VkLlxuICAgICAqL1xuICAgIHByZXZpZXc/OiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZW5jb2RpbmcgdG8gdXNlIHdoZW4gb3BlbmluZyBsb2NhbCBmaWxlcy4gSWYgc3BlY2lmaWVkLCBpdCBtdXN0IGJlIGEgdmFsdWUgc3VwcG9ydGVkIGJ5IHRoZSBGaWxlUmVhZGVyIEFQSS5cbiAgICAgKi9cbiAgICBlbmNvZGluZz86IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgb3Igbm90IHRvIHVzZSBhIHdvcmtlciB0aHJlYWQuIFVzaW5nIGEgd29ya2VyIHdpbGwga2VlcCB5b3VyIHBhZ2UgcmVhY3RpdmUsIGJ1dCBtYXkgYmUgc2xpZ2h0bHkgc2xvd2VyLlxuICAgICAqL1xuICAgIHdvcmtlcj86IGJvb2xlYW47XG5cbiAgICAvKipcbiAgICAgKiBBIHN0cmluZyB0aGF0IGluZGljYXRlcyBhIGNvbW1lbnQgKGZvciBleGFtcGxlLCBcIiNcIiBvciBcIi8vXCIpLlxuICAgICAqIFdoZW4gUGFwYSBlbmNvdW50ZXJzIGEgbGluZSBzdGFydGluZyB3aXRoIHRoaXMgc3RyaW5nLCBpdCB3aWxsIHNraXAgdGhlIGxpbmUuXG4gICAgICovXG4gICAgY29tbWVudHM/OiBmYWxzZXxzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBTdHJlYW1pbmcgaXMgbmVjZXNzYXJ5IGZvciBsYXJnZSBmaWxlcyB3aGljaCB3b3VsZCBvdGhlcndpc2UgY3Jhc2ggdGhlIGJyb3dzZXIuIFlvdSBjYW4gY2FsbCBwYXJzZXIuYWJvcnQoKSB0byBhYm9ydCBwYXJzaW5nLlxuICAgICAqIEFuZCwgZXhjZXB0IHdoZW4gdXNpbmcgYSBXZWIgV29ya2VyLCB5b3UgY2FuIGNhbGwgcGFyc2VyLnBhdXNlKCkgdG8gcGF1c2UgaXQsIGFuZCBwYXJzZXIucmVzdW1lKCkgdG8gcmVzdW1lLlxuICAgICAqL1xuICAgIHN0ZXA/OiAocmVzdWx0czogUGFyc2VSZXN1bHQsIHBhcnNlcjogUGFwYVBhcnNlUGFyc2VyKSA9PiB2b2lkOyAvLyBUT0RPXG5cbiAgICAvKipcbiAgICAgKiBUaGUgY2FsbGJhY2sgdG8gZXhlY3V0ZSB3aGVuIHBhcnNpbmcgaXMgY29tcGxldGUuIEl0IHJlY2VpdmVzIHRoZSBwYXJzZSByZXN1bHRzLiBJZiBwYXJzaW5nIGEgbG9jYWwgZmlsZSwgdGhlIEZpbGUgaXMgcGFzc2VkIGluLCB0b28uXG4gICAgICogV2hlbiBzdHJlYW1pbmcsIHBhcnNlIHJlc3VsdHMgYXJlIG5vdCBhdmFpbGFibGUgaW4gdGhpcyBjYWxsYmFjay5cbiAgICAgKi9cbiAgICBjb21wbGV0ZT86IChyZXN1bHRzOiBQYXJzZVJlc3VsdCwgZmlsZT86IEZpbGUpID0+IHZvaWQ7IC8vIFRPRE9cblxuICAgIC8qKlxuICAgICAqIEEgY2FsbGJhY2sgdG8gZXhlY3V0ZSBpZiBGaWxlUmVhZGVyIGVuY291bnRlcnMgYW4gZXJyb3IuXG4gICAgICovXG4gICAgZXJyb3I/OiAoZXJyb3I6IGFueSwgZmlsZTogYW55KSA9PiB2b2lkOyAvLyBUT0RPXG5cbiAgICAvKipcbiAgICAgKiBJZiB0cnVlLCB0aGlzIGluZGljYXRlcyB0aGF0IHRoZSBzdHJpbmcgeW91IHBhc3NlZCBhcyB0aGUgZmlyc3QgYXJndW1lbnQgdG8gcGFyc2UoKVxuICAgICAqIGlzIGFjdHVhbGx5IGEgVVJMIGZyb20gd2hpY2ggdG8gZG93bmxvYWQgYSBmaWxlIGFuZCBwYXJzZSBpdCdzIGNvbnRlbnRzLlxuICAgICAqL1xuICAgIGRvd25sb2FkPzogYm9vbGVhbjtcblxuICAgIC8qKlxuICAgICAqIEhlYWRlcnMgdG8gYmUgaW5jbHVkZWQgaW4gdGhlIGRvd25sb2FkIHJlcXVlc3QuXG4gICAgICovXG4gICAgZG93bmxvYWRSZXF1ZXN0SGVhZGVycz86IHtba2V5OiBzdHJpbmddOiBzdHJpbmd9OyAvLyBUT0RPIFRlc3QgdHlwaW5nXG5cbiAgICAvKipcbiAgICAgKiBJZiB0cnVlLCBsaW5lcyB0aGF0IGFyZSBjb21wbGV0ZWx5IGVtcHR5ICh0aG9zZSB3aGljaCBldmFsdWF0ZSB0byBhbiBlbXB0eSBzdHJpbmcpIHdpbGwgYmUgc2tpcHBlZC4gSWYgc2V0IHRvICdncmVlZHknLFxuICAgICAqIGxpbmVzIHRoYXQgZG9uJ3QgaGF2ZSBhbnkgY29udGVudCAodGhvc2Ugd2hpY2ggaGF2ZSBvbmx5IHdoaXRlc3BhY2UgYWZ0ZXIgcGFyc2luZykgd2lsbCBhbHNvIGJlIHNraXBwZWQuXG4gICAgICovXG4gICAgc2tpcEVtcHR5TGluZXM/OiBib29sZWFuIHwgJ2dyZWVkeSc7XG5cbiAgICAvKipcbiAgICAgKiBBIGNhbGxiYWNrIGZ1bmN0aW9uLCBpZGVudGljYWwgdG8gc3RlcCwgd2hpY2ggYWN0aXZhdGVzIHN0cmVhbWluZy5cbiAgICAgKiBIb3dldmVyLCB0aGlzIGZ1bmN0aW9uIGlzIGV4ZWN1dGVkIGFmdGVyIGV2ZXJ5IGNodW5rIG9mIHRoZSBmaWxlIGlzIGxvYWRlZCBhbmQgcGFyc2VkIHJhdGhlciB0aGFuIGV2ZXJ5IHJvdy5cbiAgICAgKiBXb3JrcyBvbmx5IHdpdGggbG9jYWwgYW5kIHJlbW90ZSBmaWxlcy4gRG8gbm90IHVzZSBib3RoIGNodW5rIGFuZCBzdGVwIGNhbGxiYWNrcyB0b2dldGhlci5cbiAgICAgKi9cbiAgICBjaHVuaz86IChyZXN1bHRzOiBQYXJzZVJlc3VsdCwgcGFyc2VyOiBQYXBhUGFyc2VQYXJzZXIpID0+IHZvaWQ7IC8vIFRPRE9cblxuICAgIC8qKlxuICAgICAqIEZhc3QgbW9kZSBzcGVlZHMgdXAgcGFyc2luZyBzaWduaWZpY2FudGx5IGZvciBsYXJnZSBpbnB1dHMuIEhvd2V2ZXIsIGl0IG9ubHkgd29ya3Mgd2hlbiB0aGUgaW5wdXQgaGFzIG5vIHF1b3RlZCBmaWVsZHMuXG4gICAgICogRmFzdCBtb2RlIHdpbGwgYXV0b21hdGljYWxseSBiZSBlbmFibGVkIGlmIG5vIFwiIGNoYXJhY3RlcnMgYXBwZWFyIGluIHRoZSBpbnB1dC5cbiAgICAgKiBZb3UgY2FuIGZvcmNlIGZhc3QgbW9kZSBlaXRoZXIgd2F5IGJ5IHNldHRpbmcgaXQgdG8gdHJ1ZSBvciBmYWxzZS5cbiAgICAgKi9cbiAgICBmYXN0TW9kZT86IGJvb2xlYW47XG5cbiAgICAvKipcbiAgICAgKiBBIGZ1bmN0aW9uIHRvIGV4ZWN1dGUgYmVmb3JlIHBhcnNpbmcgdGhlIGZpcnN0IGNodW5rLiBDYW4gYmUgdXNlZCB3aXRoIGNodW5rIG9yIHN0ZXAgc3RyZWFtaW5nIG1vZGVzLlxuICAgICAqIFRoZSBmdW5jdGlvbiByZWNlaXZlcyBhcyBhbiBhcmd1bWVudCB0aGUgY2h1bmsgYWJvdXQgdG8gYmUgcGFyc2VkLCBhbmQgaXQgbWF5IHJldHVybiBhIG1vZGlmaWVkIGNodW5rIHRvIHBhcnNlLlxuICAgICAqIFRoaXMgaXMgdXNlZnVsIGZvciBzdHJpcHBpbmcgaGVhZGVyIGxpbmVzIChhcyBsb25nIGFzIHRoZSBoZWFkZXIgZml0cyBpbiBhIHNpbmdsZSBjaHVuaykuXG4gICAgICovXG4gICAgYmVmb3JlRmlyc3RDaHVuaz86IChjaHVuazogc3RyaW5nKSA9PiBzdHJpbmd8dm9pZDsgLy8gVE9ET1xuXG4gICAgLyoqXG4gICAgICogQSBib29sZWFuIHZhbHVlIHBhc3NlZCBkaXJlY3RseSBpbnRvIFhNTEh0dHBSZXF1ZXN0J3MgXCJ3aXRoQ3JlZGVudGlhbHNcIiBwcm9wZXJ0eS5cbiAgICAgKi9cbiAgICB3aXRoQ3JlZGVudGlhbHM/OiBib29sZWFuO1xuXG4gICAgLyoqXG4gICAgICogQSBmdW5jdGlvbiB0byBhcHBseSBvbiBlYWNoIHZhbHVlLiBUaGUgZnVuY3Rpb24gcmVjZWl2ZXMgdGhlIHZhbHVlIGFzIGl0cyBmaXJzdCBhcmd1bWVudCBhbmQgdGhlIGNvbHVtbiBudW1iZXIgb3JcbiAgICAgKiBoZWFkZXIgbmFtZSB3aGVuIGVuYWJsZWQgYXMgaXRzIHNlY29uZCBhcmd1bWVudC4gVGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgZnVuY3Rpb24gd2lsbCByZXBsYWNlIHRoZSB2YWx1ZSBpdCByZWNlaXZlZC5cbiAgICAgKiBUaGUgdHJhbnNmb3JtIGZ1bmN0aW9uIGlzIGFwcGxpZWQgYmVmb3JlIGR5bmFtaWNUeXBpbmcuXG4gICAgICovXG4gICAgdHJhbnNmb3JtPzogKHZhbHVlOiBzdHJpbmcsIGNvbHVtbk9ySGVhZGVyOiBzdHJpbmd8bnVtYmVyKSA9PiBzdHJpbmc7IC8vIFRPRE8gdGVzdCBmdW5jdGlvblxuXG4gICAgLyoqXG4gICAgICogQW4gYXJyYXkgb2YgZGVsaW1pdGVycyB0byBndWVzcyBmcm9tIGlmIHRoZSBkZWxpbWl0ZXIgb3B0aW9uIGlzIG5vdCBzZXQuXG4gICAgICovXG4gICAgZGVsaW1pdGVyc1RvR3Vlc3M/OiBzdHJpbmdbXTtcbn1cbiJdfQ==