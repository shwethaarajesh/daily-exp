{
  "version": 3,
  "file": "rx-async-policy.js",
  "sourceRoot": "",
  "sources": [
    "@uirouter/rx/rx-async-policy.ts"
  ],
  "names": [],
  "mappings": ";;AACA,6BAAsC;AACtC,4CAAoD;AAEpD;;;;;;;;;;;;;;;;;;;GAmBG;AACU,QAAA,MAAM,GAAsB,UAAC,cAAqC;IAC7E,IAAI,CAAC,CAAC,cAAc,YAAY,iBAAU,CAAC,EAAE;QAC3C,cAAc,GAAG,SAAE,CAAC,cAAc,CAAC,CAAC;KACrC;IAED,IAAM,KAAK,GAAoB,cAAc,CAAC,IAAI,CAAC,uBAAW,CAAC,CAAC,CAAC,CAAC,CAAC;IAEnE,OAAO,KAAK;SACT,IAAI,CAAC,iBAAK,EAAE,CAAC;SACb,SAAS,EAAE;SACX,IAAI,CAAC;QACJ,OAAO,KAAK,CAAC;IACf,CAAC,CAAC,CAAC;AACP,CAAC,CAAC",
  "sourcesContent": [
    "import { CustomAsyncPolicy } from '@uirouter/core';\nimport { Observable, of } from 'rxjs';\nimport { first, shareReplay } from 'rxjs/operators';\n\n/**\n * Determines the unwrapping behavior of asynchronous resolve values.\n *\n *   - When an Observable is returned from the resolveFn, wait until the Observable emits at least one item.\n *     If any other value will be converted to an Observable that emits such value.\n *   - The Observable item will not be unwrapped.\n *   - The Observable stream itself will be provided when the resolve is injected or bound elsewhere.\n *\n * #### Example:\n *\n * The `Transition` will wait for the `main.home` resolve observables to emit their first value.\n * Promises will be unwrapped and returned as observables before being provided to components.\n * ```js\n * var mainState = {\n *   name: 'main',\n *   resolve: mainResolves, // defined elsewhere\n *   resolvePolicy: { async: RXWAIT },\n * }\n * ```\n */\nexport const RXWAIT: CustomAsyncPolicy = (resolveFnValue: Observable<any> | any): Promise<Observable<any>> => {\n  if (!(resolveFnValue instanceof Observable)) {\n    resolveFnValue = of(resolveFnValue);\n  }\n\n  const data$: Observable<any> = resolveFnValue.pipe(shareReplay(1));\n\n  return data$\n    .pipe(first())\n    .toPromise()\n    .then(() => {\n      return data$;\n    });\n};\n"
  ]
}