{
  "version": 3,
  "file": "ui-router-rx.min.js",
  "sources": [
    "@uirouter/rx/ui-router-rx.ts",
    "@uirouter/rx/rx-async-policy.ts"
  ],
  "sourcesContent": [
    "/** @module rx */\n/** */\nimport { Observable, ReplaySubject } from 'rxjs';\nimport { map, mergeMap, filter } from 'rxjs/operators';\nimport { Transition, UIRouter, StateDeclaration, UIRouterPlugin } from '@uirouter/core';\n\nexport interface StatesChangedEvent {\n  currentStates: StateDeclaration[];\n  registered: StateDeclaration[];\n  deregistered: StateDeclaration[];\n}\n\ndeclare module '@uirouter/core/lib/globals' {\n  interface UIRouterGlobals {\n    states$?: Observable<StatesChangedEvent>;\n    start$?: Observable<Transition>;\n    success$?: Observable<Transition>;\n    params$?: Observable<{ [paramName: string]: any }>;\n  }\n}\n\n/** Augments UIRouterGlobals with observables for transition starts, successful transitions, and state parameters */\nexport class UIRouterRx implements UIRouterPlugin {\n  name = '@uirouter/rx';\n  private deregisterFns: Function[] = [];\n\n  constructor(router: UIRouter) {\n    let start$ = new ReplaySubject<Transition>(1);\n    let success$ = start$.pipe(mergeMap(t => t.promise.then(() => t, () => null)), filter(t => !!t));\n    let params$ = success$.pipe(map((transition: Transition) => transition.params()));\n\n    let states$ = new ReplaySubject<StatesChangedEvent>(1);\n\n    function onStatesChangedEvent(event: string, states: StateDeclaration[]) {\n      let changeEvent = {\n        currentStates: router.stateRegistry.get(),\n        registered: [],\n        deregistered: [],\n      };\n\n      if (event) changeEvent[event] = states;\n      states$.next(changeEvent);\n    }\n\n    this.deregisterFns.push(router.transitionService.onStart({}, transition => start$.next(transition)));\n    this.deregisterFns.push(router.stateRegistry.onStatesChanged(onStatesChangedEvent));\n    onStatesChangedEvent(null, null);\n    Object.assign(router.globals, { start$, success$, params$, states$ });\n  }\n\n  dispose() {\n    this.deregisterFns.forEach(deregisterFn => deregisterFn());\n    this.deregisterFns = [];\n  }\n}\n\nexport const UIRouterRxPlugin = UIRouterRx;\n",
    "import { CustomAsyncPolicy } from '@uirouter/core';\nimport { Observable, of } from 'rxjs';\nimport { first, shareReplay } from 'rxjs/operators';\n\n/**\n * Determines the unwrapping behavior of asynchronous resolve values.\n *\n *   - When an Observable is returned from the resolveFn, wait until the Observable emits at least one item.\n *     If any other value will be converted to an Observable that emits such value.\n *   - The Observable item will not be unwrapped.\n *   - The Observable stream itself will be provided when the resolve is injected or bound elsewhere.\n *\n * #### Example:\n *\n * The `Transition` will wait for the `main.home` resolve observables to emit their first value.\n * Promises will be unwrapped and returned as observables before being provided to components.\n * ```js\n * var mainState = {\n *   name: 'main',\n *   resolve: mainResolves, // defined elsewhere\n *   resolvePolicy: { async: RXWAIT },\n * }\n * ```\n */\nexport const RXWAIT: CustomAsyncPolicy = (resolveFnValue: Observable<any> | any): Promise<Observable<any>> => {\n  if (!(resolveFnValue instanceof Observable)) {\n    resolveFnValue = of(resolveFnValue);\n  }\n\n  const data$: Observable<any> = resolveFnValue.pipe(shareReplay(1));\n\n  return data$\n    .pipe(first())\n    .toPromise()\n    .then(() => {\n      return data$;\n    });\n};\n"
  ],
  "names": [
    "UIRouterRx",
    "this",
    "deregisterFns",
    "forEach",
    "deregisterFn",
    "router",
    "start$",
    "ReplaySubject",
    "success$",
    "pipe",
    "mergeMap",
    "t",
    "promise",
    "then",
    "filter",
    "params$",
    "map",
    "transition",
    "params",
    "states$",
    "onStatesChangedEvent",
    "event",
    "states",
    "changeEvent",
    "currentStates",
    "stateRegistry",
    "get",
    "registered",
    "deregistered",
    "next",
    "push",
    "transitionService",
    "onStart",
    "onStatesChanged",
    "Object",
    "assign",
    "globals",
    "UIRouterRxPlugin",
    "resolveFnValue",
    "Observable",
    "of",
    "data$",
    "shareReplay",
    "first",
    "toPromise"
  ],
  "mappings": ";;;;;;4SAkDEA,oBAAA,WACEC,KAAKC,cAAcC,QAAQ,SAAAC,GAAgB,OAAAA,MAC3CH,KAAKC,cAAgB,OA1BvB,WAAYG,GAHZJ,UAAO,eACCA,mBAA4B,GAGlC,IAAIK,EAAS,IAAIC,gBAA0B,GACvCC,EAAWF,EAAOG,KAAKC,WAAS,SAAAC,GAAK,OAAAA,EAAEC,QAAQC,KAAK,WAAM,OAAAF,GAAG,WAAM,OAAA,SAAQG,SAAO,SAAAH,GAAK,QAAEA,KACzFI,EAAUP,EAASC,KAAKO,MAAI,SAACC,GAA2B,OAAAA,EAAWC,YAEnEC,EAAU,IAAIZ,gBAAkC,GAEpD,SAASa,EAAqBC,EAAeC,GAC3C,IAAIC,EAAc,CAChBC,cAAenB,EAAOoB,cAAcC,MACpCC,WAAY,GACZC,aAAc,IAGZP,IAAOE,EAAYF,GAASC,GAChCH,EAAQU,KAAKN,GAGftB,KAAKC,cAAc4B,KAAKzB,EAAO0B,kBAAkBC,QAAQ,GAAI,SAAAf,GAAc,OAAAX,EAAOuB,KAAKZ,MACvFhB,KAAKC,cAAc4B,KAAKzB,EAAOoB,cAAcQ,gBAAgBb,IAC7DA,EAAqB,KAAM,MAC3Bc,OAAOC,OAAO9B,EAAO+B,QAAS,CAAE9B,SAAQE,WAAUO,UAASI,gBASlDkB,EAAmBrC,WChCS,SAACsC,GAClCA,aAA0BC,eAC9BD,EAAiBE,KAAGF,IAGtB,IAAMG,EAAyBH,EAAe7B,KAAKiC,cAAY,IAE/D,OAAOD,EACJhC,KAAKkC,WACLC,YACA/B,KAAK,WACJ,OAAO4B"
}